### SELECION OF ENVIRONMENTAL AND SPATIAL DATA, AND VARIATION PARTITIONING ###
#By: Pedro V. Eisenlohr - UNEMAT, Alta Floresta (pedro.eisenlohr@unemat.br)
#Based on Bauman et al. (2018), Clappe et al. (2018), Blanchet et al. (2008) and others
### Released on: October 04, 2018

### Please refer to this code as "Eisenlohr (2014) with improvements available at http://github.com/pedroeisenlohr/variancepartition".
### Eisenlohr, P.V. (2014) doi: 10.1007/s40415-014-0064-3.

### Acknowledgments: 
### Sylvie Clappe
### Jo√£o Carlos Pires de Oliveira


library(ade4)
library(adespatial)
library(spdep)
library(vegan)
library(packfor)

##Species matrix
species<-read.table(file.choose(),row.names=1,header=T,sep=",") ###community data
View(species)
unicates<-apply(spp,2,sum) 
spp.u<-spp[,which(unicates>1)] ###removing unicates
dim(spp.u)
spp.h <- decostand(spp.u, method = "hell")

##Environmental matrix
environment <- read.table(file.choose(),row.names=1,header=T,sep=",")
View(environment)
#environment<-decostand(environment,"standardize")
View(environment)

##Spatial matrix
ll<-read.table(file.choose(),row.names=1,header=T,sep=",")
View(ll)



#### CONDENSING SPECIES MATRIX ##########
(length.pca <- (nrow(spp.h)-1))
pca.species.p <- dudi.pca(spp.h, scannf = F, nf = length.pca)
summary(pca.species.p)
# Eigenvalues
(ev<-pca.species.p$eig)

# Apply Kaiser-Guttman criterion to select axes
#(length.pca2<- length(ev[ev > mean(ev)]))
#pca.species <- dudi.pca(spp.h, scannf = F, nf = length.pca2)
#scores <- pca.species$l1
#head(scores)
#dim(scores)

# Alternatively, you may retain axes that capture about 95% of all inertia:
(explic <- pca.species.p$eig/sum(pca.species.p$eig))
(cmu <- cumsum(explic))
(length.pca3 <- which.min(cmu <= 0.95))
pca.species <- dudi.pca(spp.h, scannf = F, nf = length.pca3)
scores <- pca.species$l1
head(scores)
dim(scores)
#################################




#############################################
####### SELECTING ENVIRONMENTAL DATA ########
#############################################

### According to Blanchet et al. (2008): "It is not recommended to use a stepwise
### procedure in situations in which there are collinear variables (Chatterjee 
### and Price 1977, Freedman et al. 1992)".
### So, if you have found strong collinearities, I recommend you remove them
### before proceeding with the next step. An interesting way to address this
### issue is applying vifcor (usdm package).
# Checking collinearities
env.rda <- rda(scores, environment)
vif.cca(env.rda) ### Checking for collinearity. VIF should be < 10.
# If VIF > 10, you should remove one or more variables:
#v1<-vifcor(environment,th=0.8)
#v1
# Verify VIF. VIF should be < 10. If necessary, reduce the th.
#environment<-exclude(environment,v1)
#names(environment)

# Forward selection of the environmental variables
env.rda<-rda(scores,environment)
anova(env.rda, permutations = how(nperm=999))
### According to Blanchet et al. (2008): "If, and only if, the global 
### test is significant, one can proceed with forward selection"
(env.R2a <- RsquareAdj(env.rda)$adj.r.squared)
env.fwd <- forward.sel(scores, environment, adjR2thresh=env.R2a)
env.fwd #List of selected variables
length(env.fwd) #Number of selected variables
env.sign <- sort(env.fwd$order)
(env.red <- environment[,c(env.sign)])


#############################################
######### SELECTING SPATIAL DATA ############
#############################################

#############################################
######### SELECTING SPATIAL DATA ############
#############################################

##### OPTIMIZING THE SELECTION OF SMW #####
### The function listw.candidates is used to build the spatial weighting matrices that
### we want to test and compare (with the listw.select function). We test a Gabriel's graph, 
### a minimum spanning tree, and a distance-based connectivity defined by a threshold
### distance corresponding to the smallest distance keeping all sites connected (i.e., 
### the defaut value of d2). These connectivity matrices are then either not weighted 
### (binary weighting), or weighted by the linearly decreasing function:

candidates <- listw.candidates(coord = ll, nb = c("del", "gab", "rel", "mst",
  			"pcnm", "dnear"), weights = c("binary", "flin", "fup", "fdown"))
names(candidates)                              
(nbw<-length(candidates)) ### Number of spatial weighting matrices generated


### Optimization the selection of a subset of SWM among the candidates generated above,
### using the corrected significance threshold calculated ("forward"):
(W_sel_fwd <- listw.select(scores, candidates, MEM.autocor = "positive", method = "FWD",
                    p.adjust = TRUE, MEM.all = TRUE, nperm = 999, nperm.global = 9999, alpha = 0.05))
### Some characteristics of the best spatial model:
# Best SWM:
W_sel_fwd$best.id
(names.sel<-names(W_sel_fwd$best.id))
# Retained object for further analysis
SWM.selected<-W_sel_fwd$best$MEM.select
class(SWM.selected)
dim(SWM.selected)
write.table(SWM.selected,"SWMselected.csv")
# Write the selected MEMs to a new object
spatial.red <- as.matrix(SWM.selected)
class(spatial.red)

# Creating an object with the name of the selected SWM:
x<-data.frame(names(candidates),W_sel_fwd$candidates$R2Adj.select)
names(x)<- c('MEMS', "select")
(ms<- which.max(x$select))
candidates1=array(candidates)
(candidates.sel<-candidates1[[ms]])

######################################################

### Obtaining all spatial eigenvectors from the SWM selected above:
mem.all<-mem(candidates.sel, MEM.autocor = "all")
mem.all
class(mem.all)


#############################################
########## VARIATION PARTITIONING ###########
#############################################
scores.dudi <- dudi.pca(spp.h, scannf = F, nf=length.pca3)

vprda <- varipart(scores.dudi, env.red, spatial.red, nrepet=999)#classic variation partitioning
vprda

vprdaMSR <- msr(vprda, mem.all, nrepet = 999)#new variation partitioning 
vprdaMSR

res <- rbind(vprda$R2.adj, vprdaMSR$R2.adj.msr)
rownames(res) <- c("Standard VP", "MSR VP")
res


###########################################################################
### Testing the environmental significance, after considering #############  
### the effect of selected MEMs ###########################################
###########################################################################
env.rda<-rda(scores,env.red,spatial.red)
summary(env.rda) ### Please observe the explanation of each axis.
spenvcor(env.rda) # species-environment correlation
intersetcor(env.rda) #"interset" correlation
test.env<-anova(env.rda, permutations = how(nperm=999))
test.env
#plot(env.rda)


###########################################################################
### Testing the spatial significance, after considering ###################  
### the effect of selected env ############################################
###########################################################################
spatial.rda<-rda(scores,spatial.red,env.red)
summary(spatial.rda) ### Please observe the explanation of each axis.
spenvcor(spatial.rda) # species-environment correlation
intersetcor(spatial.rda) #"interset" correlation
test.spatial<-anova(spatial.rda, permutations = how(nperm=999))
test.spatial
#plot(spatial.rda)
